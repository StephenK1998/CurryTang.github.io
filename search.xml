<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Fluent Python Note Tip1:字典（上）]]></title>
      <url>%2Fposts%2Funcategorized%2F2017-01-25-Python%20Tips%20every%20day(Fluent%20Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0).html</url>
      <content type="text"><![CDATA[#Python Tips every day(Fluent Python学习笔记) ##Tip1:字典（上） 字典可以说是Python中最常用的数据结构之一，但它也有一些不那么为人所知的奇技淫巧，掌握它们，有助于Python程序员写出更优雅、更Pythonic的代码。 ###1.Python中映射类的继承关系 Python中的映射类从Container, Iterable, Sized三个接口继承而来，最基本的映射类为Mapping类(Abstract Class)，它实现了__getitem__ , get, keys, items等方法， 再接下来派生出了MutableMapping类，我们常用的dict便隶属于此。 In [29]: Mapping.__dict__.keys() Out[29]: dict_keys(['_abc_registry', 'get', '__doc__', '__getitem__', '_abc_negative_cache_version', '__contains__', '__module__', '__abstractmethods__', '__slots__', '_abc_cache', '_abc_negative_cache', 'items', 'values', '__eq__', '__hash__', 'keys']) In [30]: [method for method in MutableMapping.__dict__.keys() if method not in Mapping.__dict__.keys()] Out[30]: ['update', 'pop', '_MutableMapping__marker', '__setitem__', '__delitem__', 'setdefault', 'popitem', 'clear'] ###2.字典的键 什么样的值都能当作字典的键吗？Absolutely Not. Python规定Hashable Objects必须实现__hash__与__eq__这两个通用接口。简单的来说，必须是运行时不可变的值。废话少说，来看几个例子。 In [31]: my_dict = {} In [32]: key1 = [1] #不可以，list unhashable In [33]: key2 = (1,) #可以 In [34]: key3 = (1,[1,2]) #不可以，元组只要在元素都hashable时才可以做键 In [35]: key4 = (1,(1,2)) #可以 In [36]: key5 = 'abcs' #可以 In [37]: key6 = set(3,4) #不可以，set unhashable, frozenset可以用作键 一句话来总结一下，“All of Python’s immutable built-in objects are hashable” (Cited from Python Glossary) ###3. 构造字典（创建一个字典的n种方法） ####1. 重载的构造函数dict() In [43]: dict1 = dict(a = 1, b = 2) In [44]: dict2 = {'a':1, 'b':2} In [45]: dict3 = dict(zip(['a','b'],[1,2])) [1] In [46]: dict4 = dict([('a',1),('b',2)]) In [47]: dict5 = dict({'a':1, 'b':2}) In [48]: dict1 == dict2 == dict3 == dict4 == dict5 Out[48]: True Notes:[1]Find more information about zip(): zip ####2. 使用dict comprehension类似于List Comprehesion, 字典推导式提供了一种优雅、简洁的方式来创建一个Python字典。 字典推导式的语法在Python2.7 以及 3 以后是这样的 d = {k:v for k, v in iterable} 需要注意的是之前 d = {(k,v) for k, v in iterable}的写法已不再适用。 下面给出一些简单的样例In [1]: three_point_shooting = [ …: (‘curry’,99), …: (‘thompson’,98), …: (‘durant’,90), …: (‘james’,70)]In [2]: three_point_map = {player_name:ability for player_name, ability in three_point_shooting}In [3]: three_point_mapOut[3]: {‘curry’: 99, ‘durant’: 90, ‘james’: 70, ‘thompson’: 98}In [4]: {player.upper():ability for player, ability in three_point_map.items()}Out[4]: {‘CURRY’: 99, ‘DURANT’: 90, ‘JAMES’: 70, ‘THOMPSON’: 98}]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Test post]]></title>
      <url>%2Fposts%2Funcategorized%2F2017-01-03-Test-post.html</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2Fposts%2Funcategorized%2F2016-12-30-hello-world.html</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
